<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Buscador de Cartas MTG</title>
    <link rel="stylesheet" href="main.css">
</head>

<body>

    <div id="header">
        <div class="autocomplete">
            <input type="text" id="search" placeholder="Ej: black lotus" />
            <button id="searchBtn" title="Buscar">&#128269;</button>
            <div id="suggestions" class="suggestions"></div>
        </div>
    </div>

    <div id="body">
        <div id="cardsSelected">
        </div>

        <div id="cardLibraryContainer">
            <h3>Your library</h3>
            <div id="filters" style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                <label for="deckFilter">Deck:</label>
                <select id="deckFilter" style="width: fit-content;" onchange="renderLibraryTable(this.value)"></select>
                <span>Card count:</span>
                <span id="cardCount">0</span>
            </div>
            <div id="cardLibrary"></div>
        </div>
    </div>

    <div id="previewImg" class="preview-img"></div>

    <div id="overlay" style="display: none;"></div>

    <div id="importModal" style="display: none;">
        <h3>Import library</h3>
        <select id="importOption">
            <option value="">Selecciona una opciÃ³n...</option>
            <option value="csv">CSV File</option>
            <option value="sheets">Google Sheets</option>
        </select>
        <div id="csvUpload" style="margin-top: 1rem; display: none;">
            <input type="file" id="csvFileInput" accept=".csv" />
        </div>
        <div id="sheetsInput" style="margin-top: 1rem; display: none;">
            <input type="text" id="sheetUrl" placeholder="Sheet link" />
            <button id="loadBtn" onclick="loadFromGoogleSheets()">Cargar</button>
        </div>
        <button id="cancelBtn">Cancelar</button>
    </div>

    <div id="deckCreatorModal" style="display: none;">
        <h3>New deck</h3>
        <div id="deckNameInputContainer" style="margin-top: 1rem;">
            <input type="text" id="deckNameInput" placeholder="Deck name" />
        </div>
        <div id="deckSelectorContainer" style="margin-top: 1rem;">
            <label for="deckTypeSelector">Deck type:</label>
            <select id="deckTypeSelector" style="width: fit-content;">
            </select>
        </div>
        <button style="margin-top: 1rem;" id="createDeckBtn">Crear</button>
        <button id="cancelDeckCreationBtn">Cancelar</button>
    </div>

    <button id="saveCsvBtn" class="boton-flotante">ðŸ’¾</button>

    <script>

        const state = {
            deckTypes: [
                "Standard",
                "Commander",
                "EDH",
                "Modern",
                "Legacy",
                "Vintage",
                "Pioneer",
                "Brawl",
                "Pauper",
                "Historic",
                "Penny Dreadful",
                "Alchemy",
                "Explorer",
                "Frontier"
            ],
            cardLanguages: [
                "EN",
                "ES",
                "FR",
                "DE",
                "IT",
                "PT",
                "RU",
                "JA",
                "KO"
            ],
            cardsDataCache: {},
            cardsVariantDataCache: {},
            cardsInStage: {},
            decks: {},
            cardsOwned: {},
            wishList: {}
        };


        const dom = {
            input: document.getElementById("search"),
            suggestionsBox: document.getElementById("suggestions"),
            searchBtn: document.getElementById("searchBtn"),
            previewImg: document.getElementById("previewImg"),
            cardsSelected: document.getElementById("cardsSelected"),
            cardLibrary: document.getElementById("cardLibrary"),
            deckFilter: document.getElementById("deckFilter"),
            overlay: document.getElementById("overlay"),
            importModal: document.getElementById("importModal"),
            cancelBtn: document.getElementById("cancelBtn"),
            saveCsvBtn: document.getElementById("saveCsvBtn"),
            deckModal: document.getElementById("deckCreatorModal"),
            deckNameInput: document.getElementById("deckNameInput"),
            deckTypeSelector: document.getElementById("deckTypeSelector"),
            createDeckBtn: document.getElementById("createDeckBtn"),
            cancelDeckCreationBtn: document.getElementById("cancelDeckCreationBtn"),
            cardCount: document.getElementById("cardCount"),
        };

        function loadDeckTypeSelector() {
            const deckTypeSelector = dom.deckTypeSelector;
            deckTypeSelector.innerHTML = "";

            state.deckTypes.forEach(type => {
                const option = document.createElement("option");
                option.value = type;
                option.textContent = type;
                deckTypeSelector.appendChild(option);
            });
        }

        async function fetchSuggestions(query) {
            const url = `https://api.scryfall.com/cards/autocomplete?q=${encodeURIComponent(query)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.json();
        }

        async function fetchCardData(name) {
            if (state.cardsDataCache[name]) return state.cardsDataCache[name];
            const url = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            state.cardsDataCache[name] = data;
            return data;
        }

        async function fetchVariants(name) {
            if (state.cardsVariantDataCache[name]) return state.cardsVariantDataCache[name];
            const cardData = await fetchCardData(name);
            if (cardData) {
                const url = cardData.prints_search_uri;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                state.cardsVariantDataCache[name] = data;
                return data;
            }
        }

        async function handleSearch() {
            const query = dom.input.value.trim();
            if (!query) return clearSuggestions();

            try {
                const { data: suggestions } = await fetchSuggestions(query);
                renderSuggestions(suggestions);
            } catch (err) {
                console.error("Error al obtener sugerencias:", err);
                dom.suggestionsBox.innerHTML = "<div style='padding: 8px; color: red;'>Error al cargar sugerencias</div>";
            }
        }


        function renderSuggestions(suggestions) {
            dom.suggestionsBox.innerHTML = "";

            suggestions.forEach(suggestion => {
                const div = document.createElement("div");
                div.className = "suggestion";
                div.textContent = `${suggestion} (${state.cardsOwned[suggestion] ? state.cardsOwned[suggestion].length : 0})`;

                if (state.cardsInStage[suggestion]) {
                    div.style.backgroundColor = "#ddd";
                    div.style.cursor = "not-allowed";
                }

                div.onclick = () => {
                    dom.previewImg.style.display = "none";
                    showCardPreview(suggestion);
                    clearSuggestions();
                };

                div.onmouseover = () => {
                    showPreview(suggestion);
                }

                dom.suggestionsBox.appendChild(div);
            });
        }

        function clearSuggestions() {
            dom.suggestionsBox.innerHTML = "";
        }

        var clearPreview = null;

        async function showPreview(name) {
            try {
                fetchCardData(name).then((data) => {
                    if (data && data.image_uris) {
                        showCardPreviewHoveringElement(data.image_uris.normal);
                    }
                });
            } catch (err) {
                console.error("Error al mostrar la imagen de la carta:", err);
                dom.previewImg.style.display = "none";
            }
        }

        async function showCardPreviewHoveringElement(imageUrl) {
            if (!imageUrl) return;
            const img = document.createElement("img");
            img.src = imageUrl;
            img.style.maxWidth = "300px";
            img.style.maxHeight = "400px";

            dom.previewImg.innerHTML = "";
            dom.previewImg.appendChild(img);
            dom.previewImg.style.display = "block";

            if (!clearPreview) {
                clearPreview = (e) => {
                    if (e.target.closest(".suggestion") === null) {
                        dom.previewImg.style.display = "none";
                        document.body.removeEventListener("mouseover", clearPreview);
                        clearPreview = null;
                    }
                };
                document.body.addEventListener("mouseover", clearPreview);
            }

        }

        async function showCardPreview(name) {
            if (state.cardsInStage[name]) return;

            try {
                const cardData = await fetchCardData(name);
                state.cardsInStage[name] = cardData;

                const cardDiv = document.createElement("div");
                cardDiv.className = "card-preview";
                cardDiv.id = `card-${name}`;


                const cardHeader = document.createElement("div");
                cardHeader.className = "card-preview-header";
                const title = document.createElement("h3");
                title.textContent = cardData.name;

                const unstageCardButton = document.createElement("button");
                unstageCardButton.textContent = "-";
                unstageCardButton.className = "minimize";
                unstageCardButton.onclick = () => {
                    cardDiv.remove();
                    state.cardsInStage[name] = null;
                };

                cardHeader.appendChild(title);
                cardHeader.appendChild(unstageCardButton);

                cardDiv.appendChild(cardHeader);

                const cardBody = document.createElement("div");
                cardBody.className = "card-preview-body";

                const cardInfoContainer = document.createElement("div");
                cardInfoContainer.className = "card-info-container";
                cardInfoContainer.style.display = "flex";
                cardInfoContainer.style.flexDirection = "column";

                const cardTableContainer = document.createElement("div");
                cardTableContainer.id = `table-${name}`;
                cardTableContainer.className = "card-table-container";

                const img = document.createElement("img");
                img.id = `img-${name}`;
                img.src = cardData.image_uris.normal;
                img.style.maxWidth = "200px";
                img.style.maxHeight = "300px";

                const buttonsDiv = document.createElement("div");
                buttonsDiv.style.display = "flex";
                buttonsDiv.style.justifyContent = "space-between";
                buttonsDiv.style.padding = ".3rem";

                const plusWishedBtn = document.createElement("button");
                plusWishedBtn.textContent = "â¤ï¸";
                plusWishedBtn.style.border = "none";
                plusWishedBtn.style.backgroundColor = "transparent";
                plusWishedBtn.onclick = () => addCardToWishList(name);

                const plusBtn = document.createElement("button");
                plusBtn.textContent = "âž•";
                plusBtn.style.border = "none";
                plusBtn.style.backgroundColor = "transparent";
                plusBtn.onclick = () => addCardToLibrary(name);

                buttonsDiv.appendChild(plusWishedBtn);
                buttonsDiv.appendChild(plusBtn);

                cardInfoContainer.appendChild(img);

                cardInfoContainer.appendChild(buttonsDiv);

                const cardsWishedWrapper = document.createElement("div");
                cardsWishedWrapper.style.display = "flex";
                cardsWishedWrapper.style.alignItems = "center";
                cardsWishedWrapper.style.gap = "1rem";

                cardTableContainer.appendChild(cardsWishedWrapper);

                cardBody.appendChild(cardInfoContainer);
                cardBody.appendChild(cardTableContainer);
                cardDiv.appendChild(cardBody);
                dom.cardsSelected.appendChild(cardDiv);

                renderCardTable(name);

            } catch (err) {
                console.error("Error al agregar la carta:", err);
            }
        }

        function addCardToLibrary(name) {
            const newCard = {
                id: Date.now(),
                name: name,
                deck: null,
                lang: "EN",
                set: null,
                collectorNumber: null,
                foil: false
            };
            if (!state.cardsOwned[name]) state.cardsOwned[name] = [];
            state.cardsOwned[name].push(newCard);
            renderCardTable(name);
            var deckFilter = document.getElementById("deckFilter").value;
            renderLibraryTable(deckFilter);
        }

        function addCardToWishList(name) {
            const newCard = { id: Date.now(), name: name, deck: null };
            if (!state.wishList[name]) state.wishList[name] = [];
            state.wishList[name].push(newCard);
            renderCardTable(name);
            var deckFilter = document.getElementById("deckFilter").value;
            renderLibraryTable(deckFilter);
        }

        function removeCardFromLibrary(name, index) {
            const cards = state.cardsOwned[name];
            if (!cards || cards.length === 0) return;

            if (!index) {
                index = cards.findIndex(card => !card.deck);
            }

            const card = cards[index];

            if (!card) return;

            if (card.deck) {
                const card = cards[0];
                const confirmar = confirm(`La carta "${name}" estÃ¡ asociada a la deck "${card.deck}". Â¿Deseas eliminarla de todas formas?`);
                if (!confirmar) return;
            }
            cards.splice(index, 1);
            renderCardTable(name);
            var deckFilter = document.getElementById("deckFilter").value;
            renderLibraryTable(deckFilter);
        }

        async function renderCardTable(name) {
            const tableDiv = document.getElementById(`table-${name}`);
            if (!tableDiv) return;

            const oldTable = tableDiv.querySelector("table");
            if (oldTable) tableDiv.removeChild(oldTable);

            if (state.cardsOwned[name] && state.cardsOwned[name].length > 0) {
                const table = document.createElement("table");
                table.className = "card-table";
                const thead = document.createElement("thead");
                thead.innerHTML = `
            <tr>
                <th></th>
                <th>Added</th>
                <th>Deck</th>
                <th>Lang</th>
                <th>Variant</th>
                <th>Foil</th>
                <th>Price</th>
            </tr>`;
                table.appendChild(thead);

                const tbody = document.createElement("tbody");

                state.cardsOwned[name].forEach((cardObj, index) => {
                    const row = document.createElement("tr");

                    const idCell = document.createElement("td");
                    idCell.textContent = new Date(cardObj.id).toLocaleString("es-ES").replace(",", " -");

                    const deckCell = document.createElement("td");
                    const deckSelector = document.createElement("select");
                    deckSelector.className = "deck-selector";
                    deckSelector.appendChild(document.createElement("option")).textContent = "None";
                    deckSelector.lastChild.value = -1;
                    for (const deckName in state.decks) {
                        const deck = state.decks[deckName];
                        const option = document.createElement("option");
                        option.textContent = `${deck.name} (${deck.type})`;
                        option.value = deck.id;
                        deckSelector.appendChild(option);
                    }
                    deckSelector.style.display = "block";
                    const newDeckOptionNative = document.createElement("option");
                    newDeckOptionNative.textContent = "âž• New deck";
                    newDeckOptionNative.value = -2;
                    deckSelector.appendChild(newDeckOptionNative);
                    deckSelector.onchange = (e) => {
                        const selectedDeckId = parseInt(e.target.value);
                        if (selectedDeckId === -1) {
                            state.cardsOwned[name][index].deck = null;
                        } else if (selectedDeckId === -2) {
                            cardId = state.cardsOwned[name][index].id;
                            showDeckModal(cardId);
                        } else {
                            state.cardsOwned[name][index].deck = selectedDeckId;
                        }
                        var deckFilter = document.getElementById("deckFilter").value;
                        renderLibraryTable(deckFilter);
                    };
                    deckSelector.value = state.cardsOwned[name][index].deck || -1;
                    deckCell.appendChild(deckSelector);

                    const langCell = document.createElement("td");
                    const langSelect = document.createElement("select");
                    state.cardLanguages.forEach(lang => {
                        const option = document.createElement("option");
                        option.value = lang;
                        option.textContent = lang;
                        if (cardObj.lang === lang) option.selected = true;
                        langSelect.appendChild(option);
                    });
                    langSelect.onchange = () => {
                        cardObj.lang = langSelect.value;
                    };
                    langCell.appendChild(langSelect);

                    const variantCell = document.createElement("td");
                    const variantSelector = document.createElement("select");

                    const defaultOption = document.createElement("option");
                    defaultOption.value = null;
                    defaultOption.textContent = "Unespecified";
                    variantSelector.appendChild(defaultOption);

                    fetchVariants(name).then((variants) => {
                        if (variants && variants.data.length > 0) {
                            variants.data.forEach(variant => {
                                const option = document.createElement("option");
                                option.value = JSON.stringify({
                                    set: variant.set,
                                    collectorNumber: variant.collector_number,
                                    imageUrl: variant.image_uris.normal
                                });
                                option.textContent = `${variant.set_name} - [${variant.set}] - [${variant.collector_number}]`;
                                if (cardObj.id === variant.id) option.selected = true;
                                variantSelector.appendChild(option);
                            });
                        }
                        if (cardObj.set && cardObj.collectorNumber) {
                            const selectedOption = Array.from(variantSelector.options).find(option => {
                                if (option.value === "null") return false;
                                const value = JSON.parse(option.value);
                                return value.set === cardObj.set && value.collectorNumber === cardObj.collectorNumber;
                            });
                            if (selectedOption) {
                                variantSelector.value = selectedOption.value;
                            }
                        }
                    });

                    const priceCell = document.createElement("td");
                    calculatePrice(cardObj).then(price => {
                        priceCell.textContent = price || "?";
                    });

                    variantSelector.onchange = () => {
                        const cardImage = document.getElementById(`img-${name}`);
                        if (variantSelector.value === "null") {
                            cardObj.set = null;
                            cardObj.collectorNumber = null;
                            if (cardImage) {
                                cardImage.src = state.cardsDataCache[name].image_uris.normal;
                            }
                        }
                        else {
                            const value = JSON.parse(variantSelector.value);
                            cardObj.set = value.set;
                            cardObj.collectorNumber = value.collectorNumber;
                            if (cardImage) {
                                cardImage.src = value.imageUrl;
                            }
                        }
                        calculatePrice(cardObj).then(price => {
                            priceCell.textContent = price || "?";
                        });
                    };

                    variantCell.appendChild(variantSelector);

                    const foilCell = document.createElement("td");
                    const foilCheckBox = document.createElement("input");
                    foilCheckBox.type = "checkbox";
                    foilCheckBox.checked = cardObj.foil === true;
                    foilCheckBox.onchange = () => {
                        cardObj.foil = foilCheckBox.checked ? true : false;
                        calculatePrice(cardObj).then(price => {
                            priceCell.textContent = price || "?";
                        });
                    };
                    foilCell.appendChild(foilCheckBox);

                    const removeCell = document.createElement("td");
                    removeCell.style.boxShadow = "none";
                    const removeBtn = document.createElement("button");
                    removeBtn.textContent = "X";
                    removeBtn.className = "delete";
                    removeBtn.onclick = () => {
                        let eliminar = true;
                        if (cardObj.deck) {
                            eliminar = confirm(`Â¿EstÃ¡s seguro de que deseas eliminar la carta "${cardObj.name}"?`);
                        }

                        if (eliminar) {
                            removeCardFromLibrary(name, index);
                            row.remove();
                            var deckFilter = document.getElementById("deckFilter").value;
                            renderLibraryTable(deckFilter);
                        }
                    };
                    removeCell.appendChild(removeBtn);

                    row.appendChild(removeCell);
                    row.appendChild(idCell);
                    row.appendChild(deckCell);
                    row.appendChild(langCell);
                    row.appendChild(variantCell);
                    row.appendChild(foilCell);
                    row.appendChild(priceCell);


                    tbody.appendChild(row);
                });

                table.appendChild(tbody);
                tableDiv.appendChild(table);
            }
        }

        async function calculatePrice(card) {
            var price = "?";
            if (!card || !card.set || !card.collectorNumber) {
                return price;
            }
            const cardVariantsData = await fetchVariants(card.name);
            if (cardVariantsData) {
                const variant = cardVariantsData.data.find(v => v.set === card.set && v.collector_number === card.collectorNumber);
                if (variant && variant.prices) {
                    const prices = Object.entries(variant.prices).reduce(
                        (acc, [key, value]) => {
                            if (value !== null) {
                                acc[key] = value;
                            }
                            return acc;
                        },
                        {}
                    );

                    if (prices) {
                        if (card.foil && prices.usd_foil) {
                            price = prices.usd_foil;
                        } else if (prices.usd) {
                            price = prices.usd;
                        }
                    }
                    return price;
                }
            }
            
        }

        document.getElementById("importOption").addEventListener("change", (e) => {
            document.getElementById("csvUpload").style.display = "none";
            document.getElementById("sheetsInput").style.display = "none";

            if (e.target.value === "csv") {
                document.getElementById("csvUpload").style.display = "block";
            } else if (e.target.value === "sheets") {
                document.getElementById("sheetsInput").style.display = "block";
            }
        });

        document.getElementById("csvFileInput").addEventListener("change", function () {
            const file = this.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                renderLibraryFromCsv(e.target.result);
            };
            reader.readAsText(file);
        });

        function loadFromGoogleSheets() {
            const url = document.getElementById("sheetUrl").value.trim();
            if (!url) return alert("Proporciona un enlace vÃ¡lido.");
            var sheetId = url.split("/d/")[1].split("/")[0];
            var sheetGID = url.split("gid=")[1] || 0;
            fetchGoogleSheetsCSV(sheetId, sheetGID)
        }

        async function fetchGoogleSheetsCSV(sheetId, sheetGID = 0) {
            const targetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${sheetGID}`;
            try {
                const response = await fetch(targetUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const csv = await response.text();
                const importResult = renderLibraryFromCsv(csv);

                return importResult === true;
            } catch (error) {
                console.error('Error al cargar el CSV:', error);
                return false;
            }
        }

        function saveCardsToCSV() {
            const decksArray = Object.keys(state.decks).map(deckName => {
                const deck = state.decks[deckName];
                return `${deck.name};${deck.id};${deck.type}`;
            }).join("\n");

            const cardsOwnedArray = Object.keys(state.cardsOwned).map(cardName => {
                const cards = state.cardsOwned[cardName];
                return cards.map(
                    card => {
                        var deck = null;
                        if (card.deck) {
                            deck = getDeckById(card.deck);
                        }
                        var deckId = deck ? deck.id : "null";
                        var lang = card.lang || "EN";
                        var set = card.set || "null";
                        var collectorNumber = card.collectorNumber || "null";
                        var foil = 0;
                        if (card.foil) {
                            if (card.foil === true) {
                                foil = 1;
                            }
                        }
                        return `${card.name};${card.id};${deckId};${lang};${set};${collectorNumber};${foil}`;
                    }
                ).join("\n");
            }).join("\n");

            const wishListArray = Object.keys(state.wishList).map(cardName => {
                const cards = state.wishList[cardName];
                return cards.map(
                    wishedCard => {
                        var deck = null;
                        if (wishedCard.deck) {
                            deck = getDeckById(wishedCard.deck);
                        }
                        var deckId = deck ? deck.id : "null";
                        return `${wishedCard.name};${wishedCard.id};${deckId};${wishedCard.replaces || "null"}`;
                    }
                ).join("\n");
            }).join("\n");

            let csvContent = "";
            if (decksArray.length > 0) {
                csvContent += "[DECKS]\n" + decksArray + "\n";
            }
            if (cardsOwnedArray.length > 0) {
                csvContent += "[LIBRARY]\n" + cardsOwnedArray + "\n";
            }
            if (wishListArray.length > 0) {
                csvContent += "[WISH_LIST]\n" + wishListArray + "\n";
            }

            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "library.csv");
                link.style.visibility = "hidden";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function splitCsvEntities(csv) {
            const decksArray = [];
            const cardsArray = [];
            const wishListArray = [];

            const lines = csv.split("\r\n").map(line => line.trim()).filter(line => line.length > 0);
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith("[DECKS]")) {
                    i++;
                    while (i < lines.length && !lines[i].startsWith("[")) {
                        decksArray.push(lines[i].replace(/^"|"$/g, ""));
                        i++;
                    }
                    i--;
                } else if (line.startsWith("[LIBRARY]")) {
                    i++;
                    while (i < lines.length && !lines[i].startsWith("[")) {
                        cardsArray.push(lines[i].replace(/^"|"$/g, ""));
                        i++;
                    }
                    i--;
                } else if (line.startsWith("[WISH_LIST]")) {
                    i++;
                    while (i < lines.length && !lines[i].startsWith("[")) {
                        wishListArray.push(lines[i].replace(/^"|"$/g, ""));
                        i++;
                    }
                    i--;
                }
            }

            var decksCsv = null;
            if (decksArray.length > 0) {
                decksCsv = decksArray.join("\n");
            }
            var cardsCsv = null;
            if (cardsArray.length > 0) {
                cardsCsv = cardsArray.join("\n");
            }
            var wishListCsv = null;
            if (wishListArray.length > 0) {
                wishListCsv = wishListArray.join("\n");
            }

            return {
                decksCsv: decksCsv,
                cardsCsv: cardsCsv,
                wishListCsv: wishListCsv
            };
        }

        function cardsFromCsv(cardsCsv) {
            const cards = {};
            const lines = cardsCsv.split("\n").map(line => line.trim()).filter(line => line.length > 0);
            lines.forEach(line => {
                const [name, id, deck, lang, set, collectorNumber, foil] = line.split(";");
                const trimmedName = name?.trim();
                if (!trimmedName) return;
                if (!cards[trimmedName]) cards[trimmedName] = [];
                var card = {
                    id: parseInt(id),
                    name: trimmedName,
                    deck: deck ? parseInt(deck.trim()) : null || null,
                    lang: lang?.trim() || "EN",
                    set: set?.trim() || null,
                    collectorNumber: collectorNumber?.trim() || null,
                    foil: foil ? (foil == "1" ? true : false) : false
                };
                if (card.deck == 'null') card.deck = null;
                cards[trimmedName].push(card);
            });
            return cards;
        }

        function decksFromCsv(decksCsv) {
            const decks = {};
            const lines = decksCsv.split("\n").map(line => line.trim()).filter(line => line.length > 0);
            lines.forEach(line => {
                const [name, id, type] = line.split(";");
                const trimmedName = name?.trim();
                if (!trimmedName) return;
                decks[trimmedName] = { id: parseInt(id), name: trimmedName, type: type?.trim() || "EDH" };
            });
            return decks;
        }

        function wishListFromCsv(wishListCsv) {
            const wishList = {};
            const lines = wishListCsv.split("\n").map(line => line.trim()).filter(line => line.length > 0);
            lines.forEach(line => {
                const [name, id, deck, replaces] = line.split(";");
                const trimmedName = name?.trim();
                if (!trimmedName) return;
                if (!wishList[trimmedName]) wishList[trimmedName] = [];
                var card = { id: parseInt(id), name: trimmedName, deck: deck?.trim() || null, replaces: replaces?.trim() || null };
                if (card.deck == 'null') card.deck = null;
                wishList[trimmedName].push(card);
            });
            return wishList;
        }

        function renderLibraryFromCsv(csv) {
            var imported = false;

            const entities = splitCsvEntities(csv);
            if (entities.decksCsv) {
                state.decks = decksFromCsv(entities.decksCsv);
            }
            if (entities.cardsCsv) {
                state.cardsOwned = cardsFromCsv(entities.cardsCsv);
            }
            if (entities.wishListCsv) {
                state.wishList = cardsFromCsv(entities.wishListCsv);
            }

            if (state.cardsOwned || state.cardsOwned.length > 0) {
                renderLibraryTable();
                imported = true;
            }

            document.getElementById("importModal").style.display = "none";
            document.getElementById("overlay").style.display = "none";

            return imported;
        }

        function renderLibraryFilterOptions() {
            const decks = state.decks;
            const select = document.getElementById("deckFilter");
            const currenSelectedValueBuffer = select.value;

            select.innerHTML = "";

            if (decks.length === 0) {
                select.style.display = "none";
            } else {
                select.style.display = "block";

                const allOption = document.createElement("option");
                allOption.value = "__ALL__";
                allOption.textContent = "-";
                select.appendChild(allOption);

                const noneOption = document.createElement("option");
                noneOption.value = "__NONE__";
                noneOption.textContent = "No deck";
                select.appendChild(noneOption);

                for (const deckName in decks) {
                    const deck = decks[deckName];
                    const option = document.createElement("option");
                    option.value = deck.id;
                    option.textContent = `${deck.name} (${deck.type})`;
                    select.appendChild(option);
                }

                if (currenSelectedValueBuffer && select.querySelector(`option[value="${currenSelectedValueBuffer}"]`)) {
                    select.value = currenSelectedValueBuffer;
                } else {
                    select.value = "__ALL__";
                }
            }
        }

        async function renderLibraryTable(deckFilter = "__ALL__") {
            renderLibraryFilterOptions();

            dom.cardLibrary.innerHTML = "";

            let cardsCount = 0;

            var grouped = {};

            for (const cardName in state.cardsOwned) {
                const cardArray = state.cardsOwned[cardName];
                if (cardArray.length === 0) continue;
                const filteredCards = cardArray.filter(card => {
                    var suitsFilter = false;
                    if (deckFilter === "__ALL__") {
                        suitsFilter = true;
                    }
                    else if (deckFilter === "__NONE__") {
                        suitsFilter = !card.deck;
                    }
                    else {
                        const deckId = card.deck;
                        if (deckId) {
                            suitsFilter = deckId === parseInt(deckFilter);
                        }
                    }
                    return suitsFilter;
                });
                if (filteredCards.length === 0) continue;
                if (!grouped[cardName]) {
                    grouped[cardName] = [];
                }
                grouped[cardName] = grouped[cardName].concat(filteredCards);
            }

            if (Object.keys(grouped).length === 0) return;

            const table = document.createElement("table");
            table.className = "card-table";

            const thead = document.createElement("thead");
            thead.innerHTML = "<tr><th>Card</th><th>Count</th><th>Decks</th></tr>";
            table.appendChild(thead);

            const tbody = document.createElement("tbody");

            // Ordenar alfabeticamente por nombre de carta, devolver el grouped, pero ordenado
            grouped = Object.keys(grouped).sort((a, b) => a.localeCompare(b));

            for (const cardName in grouped) {
                const cards = grouped[cardName];
                const count = cards.length;

                const deckCounts = {};
                cards.forEach(card => {
                    var deckName = "None";
                    if (card.deck) {
                        var deck = getDeckById(card.deck);
                        if (deck) {
                            deckName = deck.name;
                        }
                    }
                    deckCounts[deckName] = (deckCounts[deckName] || 0) + 1;
                });

                const deckSummary = Object.entries(deckCounts)
                    .map(([deckName, qty]) => `${deckName} (${qty})`)
                    .join(", ");

                const row = document.createElement("tr");

                const nameCell = document.createElement("td");
                nameCell.textContent = cardName;
                nameCell.style.cursor = "pointer";
                nameCell.addEventListener("click", () => showCardPreview(cardName));

                const countCell = document.createElement("td");
                countCell.textContent = count;

                const deckCell = document.createElement("td");
                deckCell.textContent = deckSummary;

                row.appendChild(nameCell);
                row.appendChild(countCell);
                row.appendChild(deckCell);

                tbody.appendChild(row);
                cardsCount += count;
            }

            table.appendChild(tbody);
            dom.cardLibrary.appendChild(table);
            dom.cardCount.textContent = `${cardsCount}`;
        }

        dom.input.addEventListener("input", () => {
            dom.input.value.endsWith(" ") ? handleSearch() : clearSuggestions();
        });

        dom.input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                handleSearch();
            }
        });

        dom.searchBtn.addEventListener("click", handleSearch);

        document.addEventListener("click", (e) => {
            if (!e.target.closest(".autocomplete")) clearSuggestions();
        });

        document.addEventListener("mousemove", (e) => {
            dom.previewImg.style.left = `${e.pageX + 10}px`;
            dom.previewImg.style.top = `${e.pageY + 10}px`;
        });

        dom.overlay.addEventListener("click", () => {
            closeImportModal();
            closeDeckModal();
        });

        dom.cancelDeckCreationBtn.addEventListener("click", () => {
            closeDeckModal();
        });

        dom.cancelBtn.addEventListener("click", () => {
            closeImportModal();
        });

        dom.saveCsvBtn.addEventListener("click", () => {
            saveCardsToCSV();
        });

        function getUrlParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        document.addEventListener('DOMContentLoaded', function () {
            window.addEventListener("load", () => {
                const sheetId = getUrlParam('sheetId');
                const sheetGID = getUrlParam('sheetGID') || 0;

                if (sheetId) {
                    fetchGoogleSheetsCSV(sheetId, sheetGID).then((importResult) => {
                        if (importResult === true) {
                            closeImportModal();
                        } else {
                            if (Object.keys(state.cardsOwned).length === 0) {
                                showImportModal();
                            }
                        }
                    });
                }
                else {
                    if (Object.keys(state.cardsOwned).length === 0) {
                        showImportModal();
                    }
                }

                loadDeckTypeSelector();
            });
        });

        function showImportModal() {
            dom.overlay.style.display = "block";
            dom.importModal.style.display = "block";
        }

        function closeImportModal() {
            dom.overlay.style.display = "none";
            dom.importModal.style.display = "none";
        }

        function showDeckModal(cardId) {
            dom.overlay.style.display = "block";
            dom.deckModal.style.display = "block";

            const deckNameInput = document.getElementById("deckNameInput");
            const dedcCreationConfirmButton = document.getElementById("createDeckBtn");
            const deckTypeSelector = document.getElementById("deckTypeSelector");

            dedcCreationConfirmButton.onclick = () => {
                newDeckName = deckNameInput.value.trim();
                if (!newDeckName || newDeckName.length == 0) {
                    alert("Proporciona un nombre de deck vÃ¡lido.");
                }
                else {
                    if (state.decks[newDeckName]) {
                        alert("Ya existe un deck con ese nombre.");
                    }
                    else {
                        deck = {
                            id: Date.now(),
                            name: newDeckName,
                            type: deckTypeSelector.value
                        }
                        state.decks[newDeckName] = deck;
                        if (cardId) {
                            var card = Object.values(state.cardsOwned).flat().find(card => card.id === cardId);
                            if (card) {
                                card.deck = deck.id;
                                renderCardTable(card.name);
                                var deckFilter = document.getElementById("deckFilter").value;
                                renderLibraryTable(deckFilter);
                            }
                        }
                        closeDeckModal();
                    }
                }
            };
        }

        function getDeckById(deckId) {
            return Object.values(state.decks).find(deck => deck.id === deckId);
        }

        function getCardById(cardId) {
            return Object.values(state.cardsOwned).flat().find(card => card.id === cardId);
        }

        function closeDeckModal() {
            dom.overlay.style.display = "none";
            dom.deckModal.style.display = "none";
            document.getElementById("deckNameInput").value = "";
        }

    </script>
</body>

</html>